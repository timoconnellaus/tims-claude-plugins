#!/usr/bin/env bun

/**
 * Build script for compiling req and docs CLIs to standalone binaries
 *
 * Usage: bun run scripts/build.ts [--version <version>] [--cli <name>]
 *
 * This script:
 * 1. Builds the UI with Vite + Nitro -> .output/
 * 2. Generates embedded-server.ts that imports all .output files
 * 3. Compiles CLI binary with production flag
 *
 * Output: dist/<cli>-<os>-<arch>
 */

import { $ } from "bun";
import { join, relative, dirname, basename } from "path";
import { Glob } from "bun";

const GITHUB_REPO = "timoconnellaus/tims-claude-plugins";

// Target platforms for cross-compilation
const TARGETS = [
  { os: "darwin", arch: "arm64", bunTarget: "bun-darwin-arm64" },
  { os: "darwin", arch: "x64", bunTarget: "bun-darwin-x64" },
  { os: "linux", arch: "x64", bunTarget: "bun-linux-x64" },
  { os: "linux", arch: "arm64", bunTarget: "bun-linux-arm64" },
] as const;

// CLI configurations
const CLIS = [
  {
    name: "req",
    entrypoint: "plugins/requirements-tracker/src/cli.ts",
    packageJson: "plugins/requirements-tracker/package.json",
    pluginDir: "plugins/requirements-tracker",
  },
  {
    name: "docs",
    entrypoint: "plugins/docs-skill/src/cli.ts",
    packageJson: "plugins/docs-skill/package.json",
    pluginDir: "plugins/docs-skill",
  },
] as const;

const ROOT = join(import.meta.dir, "..");

async function getVersion(packageJsonPath: string): Promise<string> {
  const fullPath = join(ROOT, packageJsonPath);
  const pkg = await Bun.file(fullPath).json();
  return pkg.version;
}

function parseArgs(): { version?: string; cli?: string } {
  const args = process.argv.slice(2);
  const result: { version?: string; cli?: string } = {};

  for (let i = 0; i < args.length; i++) {
    if (args[i] === "--version" && args[i + 1]) {
      result.version = args[i + 1].replace(/^v/, "");
      i++;
    } else if (args[i] === "--cli" && args[i + 1]) {
      result.cli = args[i + 1];
      i++;
    }
  }

  return result;
}

// Write build constants to a file that gets imported
async function writeBuildConstants(
  pluginDir: string,
  version: string,
  cliName: string
): Promise<string> {
  const constantsPath = join(pluginDir, "src/lib/build-constants.ts");
  const content = `// Auto-generated by build script - DO NOT EDIT
export const CLI_VERSION = ${JSON.stringify(version)};
export const CLI_NAME = ${JSON.stringify(cliName)};
export const GITHUB_REPO = ${JSON.stringify(GITHUB_REPO)};
export const IS_PRODUCTION = true;
`;
  await Bun.write(constantsPath, content);
  return constantsPath;
}

// Create a simple hash for variable names
function hashPath(path: string): string {
  let hash = 0;
  for (let i = 0; i < path.length; i++) {
    const char = path.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

// Build UI with Vite + Nitro
async function buildUI(pluginDir: string): Promise<void> {
  const fullPluginDir = join(ROOT, pluginDir);

  console.log("  Building UI with Vite + Nitro...");

  const proc = Bun.spawn(["bunx", "vite", "build"], {
    cwd: fullPluginDir,
    stdout: "pipe",
    stderr: "pipe",
  });

  await proc.exited;

  if (proc.exitCode !== 0) {
    const stderr = await new Response(proc.stderr).text();
    throw new Error(`Vite build failed: ${stderr}`);
  }

  // Verify .output was created (Nitro outputs to src/ui/.output due to vite root config)
  const outputDir = join(fullPluginDir, "src/ui/.output");
  const serverPath = join(outputDir, "server", "index.mjs");
  if (!(await Bun.file(serverPath).exists())) {
    throw new Error(
      "Nitro build failed - src/ui/.output/server/index.mjs not found. " +
        "Make sure the nitro plugin is configured in vite.config.ts"
    );
  }

  console.log("  UI build complete");
}

// Generate embedded-server.ts that imports all .output files
async function generateEmbeddedServerModule(pluginDir: string): Promise<void> {
  const fullPluginDir = join(ROOT, pluginDir);
  // Nitro outputs to src/ui/.output due to vite root config
  const outputDir = join(fullPluginDir, "src/ui/.output");
  const embeddedServerPath = join(fullPluginDir, "src/lib/embedded-server.ts");

  console.log("  Generating embedded-server.ts...");

  // Find all files in .output directory
  const glob = new Glob("**/*");
  const files: string[] = [];

  for await (const file of glob.scan({ cwd: outputDir, onlyFiles: true })) {
    files.push(file);
  }

  if (files.length === 0) {
    throw new Error("No files found in .output directory");
  }

  // Generate imports and extraction code
  let imports = "";
  let extractions = "";
  let dirCreations = new Set<string>();

  for (const file of files) {
    const varName = `file_${hashPath(file)}`;
    // Import path is relative to src/lib/embedded-server.ts
    const filePath = `../ui/.output/${file}`;

    imports += `import ${varName} from ${JSON.stringify(filePath)} with { type: "file" };\n`;

    // Track directories that need to be created
    const fileDir = dirname(file);
    if (fileDir && fileDir !== ".") {
      dirCreations.add(fileDir);
    }

    extractions += `  await Bun.write(\`\${extractDir}/${file}\`, Bun.file(${varName}));\n`;
  }

  // Generate directory creation code
  let dirCode = "";
  const sortedDirs = Array.from(dirCreations).sort();
  for (const dir of sortedDirs) {
    dirCode += `  await Bun.$\`mkdir -p \${extractDir}/${dir}\`.quiet();\n`;
  }

  const moduleContent = `// Auto-generated by build script - DO NOT EDIT
// This file embeds the Nitro server output for production builds
${imports}

declare const __CLI_VERSION__: string;

const CACHE_DIR = \`\${process.env.HOME}/.cache/tims-claude-skills\`;

/**
 * Extract embedded server files to cache directory.
 * Returns the directory path where files were extracted.
 */
export async function extractEmbeddedServer(): Promise<string> {
  let version: string;
  try {
    version = __CLI_VERSION__;
  } catch {
    version = "dev";
  }

  const extractDir = \`\${CACHE_DIR}/server-\${version}\`;

  // Skip extraction if already done
  if (await Bun.file(\`\${extractDir}/server/index.mjs\`).exists()) {
    return extractDir;
  }

  console.log("Extracting server files...");

  // Create directories
  await Bun.$\`mkdir -p \${extractDir}\`.quiet();
${dirCode}

  // Extract all embedded files
${extractions}

  console.log(\`Server files extracted to \${extractDir}\`);
  return extractDir;
}
`;

  await Bun.write(embeddedServerPath, moduleContent);
  console.log(`  Generated embedded-server.ts (${files.length} files embedded)`);
}

async function build() {
  const { version: overrideVersion, cli: targetCli } = parseArgs();

  // Filter CLIs if specific one requested
  const clisToBuild = targetCli
    ? CLIS.filter((c) => c.name === targetCli)
    : CLIS;

  if (clisToBuild.length === 0) {
    console.error(`Unknown CLI: ${targetCli}`);
    console.log(`Available: ${CLIS.map((c) => c.name).join(", ")}`);
    process.exit(1);
  }

  // Clean and create dist directory
  const distDir = join(ROOT, "dist");
  await $`rm -rf ${distDir} && mkdir -p ${distDir}`.quiet();

  console.log("Building CLIs for distribution...\n");

  for (const cli of clisToBuild) {
    const version = overrideVersion || (await getVersion(cli.packageJson));
    console.log(`Building ${cli.name} v${version}`);
    console.log("â”€".repeat(40));

    const fullPluginDir = join(ROOT, cli.pluginDir);

    // Step 1: Build UI with Vite + Nitro
    await buildUI(cli.pluginDir);

    // Step 2: Generate embedded-server.ts
    await generateEmbeddedServerModule(cli.pluginDir);

    // Step 3: Write build constants
    await writeBuildConstants(fullPluginDir, version, cli.name);

    // Step 4: Compile CLI binary for each target
    for (const target of TARGETS) {
      const outfile = join(distDir, `${cli.name}-${target.os}-${target.arch}`);
      const entrypoint = join(ROOT, cli.entrypoint);

      process.stdout.write(`  ${target.os}-${target.arch}... `);

      try {
        // Use bun build CLI for cross-compilation
        const cmd = [
          "bun",
          "build",
          "--compile",
          `--target=${target.bunTarget}`,
          "--minify",
          entrypoint,
          "--outfile",
          outfile,
        ];

        const proc = Bun.spawn(cmd, { stdout: "pipe", stderr: "pipe" });
        await proc.exited;
        if (proc.exitCode !== 0) {
          const stderr = await new Response(proc.stderr).text();
          throw new Error(stderr);
        }

        // Get file size
        const stat = await Bun.file(outfile).stat();
        const sizeMB = (stat.size / (1024 * 1024)).toFixed(1);
        console.log(`done (${sizeMB} MB)`);
      } catch (error) {
        console.log("FAILED");
        console.error(`    Error: ${error}`);
        process.exit(1);
      }
    }

    console.log("");
  }

  // Generate checksums
  console.log("Generating checksums...");
  const checksumFile = join(distDir, "checksums.txt");
  const files = await $`ls ${distDir}`.text();
  const binaries = files
    .trim()
    .split("\n")
    .filter((f) => !f.endsWith(".txt"));

  let checksums = "";
  for (const binary of binaries) {
    const hash =
      await $`shasum -a 256 ${join(distDir, binary)} | cut -d' ' -f1`.text();
    checksums += `${hash.trim()}  ${binary}\n`;
  }
  await Bun.write(checksumFile, checksums);
  console.log(`  Created ${checksumFile}\n`);

  console.log("Build complete!");
  console.log(`Output directory: ${distDir}`);
}

build().catch((error) => {
  console.error("Build failed:", error);
  process.exit(1);
});
