/**
 * Auto-update module for CLI binaries
 *
 * This file should be copied to each plugin's src/lib/ directory.
 * It handles checking for updates and self-updating the binary.
 */

// Import build constants (generated by build script, or fallback defaults)
let CLI_VERSION = "0.0.0-dev";
let CLI_NAME = "cli";
let GITHUB_REPO = "timoconnellaus/tims-claude-plugins";

try {
  // Dynamic import to allow running without build-constants.ts
  const constants = await import("./build-constants");
  CLI_VERSION = constants.CLI_VERSION;
  CLI_NAME = constants.CLI_NAME;
  GITHUB_REPO = constants.GITHUB_REPO;
} catch {
  // Use defaults if build-constants.ts doesn't exist (dev mode)
}

const CACHE_DIR = `${process.env.HOME}/.cache/tims-claude-skills`;
const UPDATE_CHECK_FILE = `${CACHE_DIR}/update-check.json`;
const CHECK_INTERVAL_MS = 24 * 60 * 60 * 1000; // 24 hours

interface ReleaseInfo {
  version: string;
  downloadUrl: string;
  publishedAt: string;
}

interface UpdateCheckCache {
  lastCheck: string;
  latestVersion: string;
}

// Get current version
export function getCurrentVersion(): string {
  return CLI_VERSION;
}

// Get CLI name
export function getCliName(): string {
  return CLI_NAME;
}

// Get GitHub repo
function getGithubRepo(): string {
  return GITHUB_REPO;
}

// Detect current platform
function detectPlatform(): string {
  const os = process.platform === "darwin" ? "darwin" : "linux";
  const arch = process.arch === "arm64" ? "arm64" : "x64";
  return `${os}-${arch}`;
}

// Compare semantic versions - returns true if latest > current
function isNewerVersion(current: string, latest: string): boolean {
  const parse = (v: string) =>
    v
      .replace(/^v/, "")
      .split(".")
      .map((n) => parseInt(n, 10) || 0);
  const [c, l] = [parse(current), parse(latest)];

  for (let i = 0; i < 3; i++) {
    if ((l[i] || 0) > (c[i] || 0)) return true;
    if ((l[i] || 0) < (c[i] || 0)) return false;
  }
  return false;
}

// Read update check cache
async function readCache(): Promise<UpdateCheckCache | null> {
  try {
    const file = Bun.file(UPDATE_CHECK_FILE);
    if (await file.exists()) {
      return await file.json();
    }
  } catch {
    // Ignore cache read errors
  }
  return null;
}

// Write update check cache
async function writeCache(cache: UpdateCheckCache): Promise<void> {
  try {
    await Bun.$`mkdir -p ${CACHE_DIR}`.quiet();
    await Bun.write(UPDATE_CHECK_FILE, JSON.stringify(cache));
  } catch {
    // Ignore cache write errors
  }
}

// Fetch latest release info from GitHub
async function fetchLatestRelease(): Promise<ReleaseInfo | null> {
  try {
    const repo = getGithubRepo();
    const response = await fetch(
      `https://api.github.com/repos/${repo}/releases/latest`,
      {
        headers: {
          Accept: "application/vnd.github.v3+json",
          "User-Agent": `${getCliName()}/${getCurrentVersion()}`,
        },
      }
    );

    if (!response.ok) return null;

    const data = (await response.json()) as {
      tag_name: string;
      published_at: string;
      assets?: Array<{ name: string; browser_download_url: string }>;
    };
    const platform = detectPlatform();
    const cliName = getCliName();
    const assetName = `${cliName}-${platform}`;

    const asset = data.assets?.find((a) => a.name === assetName);
    if (!asset) return null;

    return {
      version: data.tag_name.replace(/^v/, ""),
      downloadUrl: asset.browser_download_url,
      publishedAt: data.published_at,
    };
  } catch {
    return null;
  }
}

// Check for updates (with caching)
export async function checkForUpdates(force = false): Promise<{
  hasUpdate: boolean;
  currentVersion: string;
  latestVersion: string | null;
}> {
  const currentVersion = getCurrentVersion();

  // Check cache first (unless forced)
  if (!force) {
    const cache = await readCache();
    if (cache) {
      const lastCheck = new Date(cache.lastCheck).getTime();
      if (Date.now() - lastCheck < CHECK_INTERVAL_MS) {
        return {
          hasUpdate: isNewerVersion(currentVersion, cache.latestVersion),
          currentVersion,
          latestVersion: cache.latestVersion,
        };
      }
    }
  }

  // Fetch latest release
  const release = await fetchLatestRelease();
  if (!release) {
    return { hasUpdate: false, currentVersion, latestVersion: null };
  }

  // Update cache
  await writeCache({
    lastCheck: new Date().toISOString(),
    latestVersion: release.version,
  });

  return {
    hasUpdate: isNewerVersion(currentVersion, release.version),
    currentVersion,
    latestVersion: release.version,
  };
}

// Perform self-update
export async function selfUpdate(): Promise<boolean> {
  const currentVersion = getCurrentVersion();
  const cliName = getCliName();

  console.log(`Checking for updates to ${cliName}...`);
  console.log(`Current version: ${currentVersion}`);

  const release = await fetchLatestRelease();
  if (!release) {
    console.error("Failed to fetch latest release information");
    return false;
  }

  console.log(`Latest version: ${release.version}`);

  if (!isNewerVersion(currentVersion, release.version)) {
    console.log("You're already running the latest version!");
    return true;
  }

  console.log(`\nDownloading ${cliName} v${release.version}...`);

  try {
    // Download new binary to temp location
    const response = await fetch(release.downloadUrl);
    if (!response.ok) {
      throw new Error(`Download failed: ${response.statusText}`);
    }

    const tmpPath = `/tmp/${cliName}-update-${Date.now()}`;
    await Bun.write(tmpPath, response);
    await Bun.$`chmod +x ${tmpPath}`.quiet();

    // Get current binary path
    const currentPath = process.execPath;

    // Replace current binary
    // On Unix, we can rename over a running binary
    const backupPath = `${currentPath}.backup`;

    console.log(`Updating ${currentPath}...`);

    // Create backup
    await Bun.$`cp ${currentPath} ${backupPath}`.quiet();

    try {
      // Replace with new version
      await Bun.$`mv ${tmpPath} ${currentPath}`.quiet();

      // Remove backup on success
      await Bun.$`rm -f ${backupPath}`.quiet();

      console.log(`\nSuccessfully updated ${cliName} to v${release.version}!`);
      console.log("Run the command again to use the new version.");

      return true;
    } catch (error) {
      // Restore from backup
      console.error("Update failed, restoring backup...");
      await Bun.$`mv ${backupPath} ${currentPath}`.quiet();
      throw error;
    }
  } catch (error) {
    console.error(`Update failed: ${error}`);
    return false;
  }
}

// Check for updates on startup (non-blocking notification)
export async function maybeNotifyUpdate(): Promise<void> {
  try {
    const { hasUpdate, latestVersion } = await checkForUpdates();
    if (hasUpdate && latestVersion) {
      const cliName = getCliName();
      console.log(
        `\n[Update available] ${cliName} v${latestVersion} is available. Run '${cliName} upgrade' to update.\n`
      );
    }
  } catch {
    // Silently ignore update check failures
  }
}
